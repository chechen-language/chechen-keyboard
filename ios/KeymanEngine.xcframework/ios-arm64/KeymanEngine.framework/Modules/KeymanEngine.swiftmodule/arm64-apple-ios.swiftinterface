// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios12.2 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name KeymanEngine
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AudioToolbox
import CoreText
import DeviceKit
import Foundation
import QuartzCore
import Reachability
import Sentry
import Swift
import UIKit
import WebKit
import XCGLogger
import ZIPFoundation
import _Concurrency
import _StringProcessing
public let log: XCGLogger.XCGLogger
public struct FullLexicalModelID : Swift.Codable, KeymanEngine.LanguageResourceFullID, Swift.Equatable {
  public typealias Resource = KeymanEngine.InstallableLexicalModel
  public var lexicalModelID: Swift.String
  public var languageID: Swift.String
  public var id: Swift.String {
    get
  }
  public var type: KeymanEngine.LanguageResourceType {
    get
  }
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension KeymanEngine.FullLexicalModelID : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct Font : Swift.Codable {
  public let family: Swift.String
  public let source: [Swift.String]
  public let size: Swift.String
  public init(family: Swift.String, source: [Swift.String], size: Swift.String? = nil)
  public init(filename: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct InstallableKeyboard : Swift.Codable {
  public typealias FullID = KeymanEngine.FullKeyboardID
  public typealias Package = KeymanEngine.KeyboardKeymanPackage
  public var id: Swift.String {
    get
  }
  public var packageID: Swift.String? {
    get
  }
  public var name: Swift.String
  public var lgCode: Swift.String {
    get
  }
  public var languageName: Swift.String
  public var version: Swift.String
  public var isRTL: Swift.Bool
  public var font: KeymanEngine.Font?
  public var oskFont: KeymanEngine.Font?
  public var isCustom: Swift.Bool
  public var displayName: Swift.String?
  public static let sharingLink: Swift.String
  public var sharableURL: Swift.String? {
    get
  }
  public var languageID: Swift.String {
    get
  }
  public var typedFullID: KeymanEngine.FullKeyboardID {
    get
  }
  public var fullID: KeymanEngine.FullKeyboardID {
    get
  }
  public init(id: Swift.String, name: Swift.String, languageID: Swift.String, languageName: Swift.String, version: Swift.String, isRTL: Swift.Bool, font: KeymanEngine.Font?, oskFont: KeymanEngine.Font?, isCustom: Swift.Bool)
  public init(keyboard: KeymanEngine.Keyboard, language: KeymanEngine.Language, isCustom: Swift.Bool)
  public var fonts: [KeymanEngine.Font] {
    get
  }
  public var sourceFilename: Swift.String {
    get
  }
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension KeymanEngine.Colors {
  public static var systemBackground: UIKit.UIColor {
    get
  }
  public static var selectionPrimary: UIKit.UIColor {
    get
  }
  public static var selectionSecondary: UIKit.UIColor {
    get
  }
  public static var statusToolbar: UIKit.UIColor {
    get
  }
  public static var statusResourceUpdateButton: UIKit.UIColor {
    get
  }
  public static var spinnerBackground: UIKit.UIColor {
    get
  }
  public static var labelNormal: UIKit.UIColor {
    get
  }
  public static var labelHighlighted: UIKit.UIColor {
    get
  }
  public static var listSeparator: UIKit.UIColor {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class ResourceDownloadStatusToolbar : UIKit.UIToolbar {
  @_Concurrency.MainActor(unsafe) public var navigationController: UIKit.UINavigationController? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public func displayStatus(_ text: Swift.String, withIndicator: Swift.Bool, duration: Foundation.TimeInterval? = nil)
  @_Concurrency.MainActor(unsafe) public func displayButton(_ text: Swift.String, with target: Any?, callback: ObjectiveC.Selector)
  @objc deinit
}
@objc public class Version : ObjectiveC.NSObject, Swift.Comparable {
  public enum Tier : Swift.String {
    case alpha
    case beta
    case stable
    public static func < (lhs: KeymanEngine.Version.Tier, rhs: KeymanEngine.Version.Tier) -> Swift.Bool
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public static let fallback: KeymanEngine.Version
  public static let latestFeature: KeymanEngine.Version
  public static var current: KeymanEngine.Version {
    get
  }
  public static var currentTagged: KeymanEngine.Version {
    get
  }
  public static let freshInstall: KeymanEngine.Version
  public static let firstTracked: KeymanEngine.Version
  public static let fileBrowserImplemented: KeymanEngine.Version
  public static let defaultsNeedBackup: KeymanEngine.Version
  public static let packageBasedFileReorg: KeymanEngine.Version
  final public let plainString: Swift.String
  final public let fullString: Swift.String
  final public let tier: KeymanEngine.Version.Tier?
  public var major: Swift.Int {
    get
  }
  public init?(_ string: Swift.String)
  public init?(_ components: [Swift.Int], tier: KeymanEngine.Version.Tier? = nil)
  public static func < (lhs: KeymanEngine.Version, rhs: KeymanEngine.Version) -> Swift.Bool
  public static func == (lhs: KeymanEngine.Version, rhs: KeymanEngine.Version) -> Swift.Bool
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  public var majorMinor: KeymanEngine.Version {
    get
  }
  @objc deinit
}
public protocol KeymanResponder {
  func summonKeyboard()
  func dismissKeyboard()
  func showKeyboardPicker() -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class TextView : UIKit.UITextView, KeymanEngine.KeymanResponder {
  @_Concurrency.MainActor(unsafe) public var viewController: UIKit.UIViewController?
  @_Concurrency.MainActor(unsafe) public var shouldSetCustomFontOnKeyboardChange: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var isInputClickSoundEnabled: Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc convenience dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc convenience dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect, textContainer: UIKit.NSTextContainer?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var inputViewController: UIKit.UIInputViewController? {
    @objc get
    @objc set(inputViewController)
  }
  @_Concurrency.MainActor(unsafe) @objc override weak dynamic public var delegate: UIKit.UITextViewDelegate? {
    @objc get
    @objc set(delegate)
  }
  @_Concurrency.MainActor(unsafe) public func setKeymanDelegate(_ keymanDelegate: KeymanEngine.TextViewDelegate?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var text: Swift.String! {
    @objc get
    @objc set(text)
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var selectedTextRange: UIKit.UITextRange? {
    @objc get
    @objc set
  }
  @objc deinit
}
extension KeymanEngine.KeymanResponder where Self : KeymanEngine.TextView {
  public func dismissKeyboard()
  public func summonKeyboard()
  public func showKeyboardPicker() -> Swift.Bool
}
extension KeymanEngine.TextView : UIKit.UITextViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textViewDidChangeSelection(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textViewShouldBeginEditing(_ textView: UIKit.UITextView) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textViewDidBeginEditing(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textView(_ textView: UIKit.UITextView, shouldChangeTextIn range: Foundation.NSRange, replacementText text: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textViewDidChange(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textViewShouldEndEditing(_ textView: UIKit.UITextView) -> Swift.Bool
}
public enum Migrations {
  public static var engineVersion: KeymanEngine.Version? {
    get
  }
}
public enum LanguageResourceType : Swift.String, Swift.Codable {
  case keyboard
  case lexicalModel
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol AnyLanguageResourceFullID {
  var id: Swift.String { get }
  var languageID: Swift.String { get }
  var type: KeymanEngine.LanguageResourceType { get }
  func matches(_ other: KeymanEngine.AnyLanguageResourceFullID, requireLanguageMatch: Swift.Bool) -> Swift.Bool
}
extension KeymanEngine.AnyLanguageResourceFullID {
  public func matches(_ other: KeymanEngine.AnyLanguageResourceFullID, requireLanguageMatch: Swift.Bool = true) -> Swift.Bool
}
extension KeymanEngine.AnyLanguageResourceFullID where Self : Swift.Equatable {
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
}
public protocol LanguageResourceFullID : KeymanEngine.AnyLanguageResourceFullID {
  associatedtype Resource : KeymanEngine.LanguageResource where Self == Self.Resource.FullID
}
public protocol AnyLanguageResource {
  var id: Swift.String { get }
  var name: Swift.String { get }
  var languageID: Swift.String { get }
  var packageID: Swift.String? { get }
  var packageKey: KeymanEngine.KeymanPackage.Key { get }
  var fullID: KeymanEngine.AnyLanguageResourceFullID { get }
  var version: Swift.String { get }
  var sharableURL: Swift.String? { get }
  var fonts: [KeymanEngine.Font] { get }
  var sourceFilename: Swift.String { get }
}
extension KeymanEngine.AnyLanguageResource {
  public var packageKey: KeymanEngine.KeymanPackage.Key {
    get
  }
}
public protocol LanguageResource : KeymanEngine.AnyLanguageResource {
  associatedtype FullID : KeymanEngine.LanguageResourceFullID, Swift.Equatable where Self == Self.FullID.Resource
  associatedtype Package : KeymanEngine.KeymanPackage
  var typedFullID: Self.FullID { get }
}
extension KeymanEngine.LanguageResource {
  public var fullID: KeymanEngine.AnyLanguageResourceFullID {
    get
  }
}
extension Foundation.NotificationCenter {
  public func post<T>(name: KeymanEngine.NotificationName<T>, object: Any? = nil, value: T)
  public func addObserver<T>(forName name: KeymanEngine.NotificationName<T>, object: Any? = nil, queue: Foundation.OperationQueue? = nil, using block: @escaping (T) -> Swift.Void) -> KeymanEngine.NotificationObserver
  public func addObserver<O, T>(forName name: KeymanEngine.NotificationName<T>, object: Any? = nil, queue: Foundation.OperationQueue? = nil, observer: O, function: @escaping (O) -> (T) -> Swift.Void) -> KeymanEngine.NotificationObserver where O : AnyObject
  public func addObserver<O, T>(forName name: KeymanEngine.NotificationName<T>, object: Any? = nil, queue: Foundation.OperationQueue? = nil, observer: O, function: @escaping (O) -> () -> Swift.Void) -> KeymanEngine.NotificationObserver where O : AnyObject
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class KeyboardSearchViewController : UIKit.UIViewController, WebKit.WKNavigationDelegate {
  public enum SearchDownloadResult {
    case success(KeymanEngine.KeymanPackage, KeymanEngine.AnyLanguageResourceFullID)
    case cancelled
    case error(Swift.Error?)
  }
  public enum SearchResult<FullID> where FullID : KeymanEngine.LanguageResourceFullID {
    case cancelled
    case untagged(KeymanEngine.KeymanPackage.Key, Foundation.URL)
    case tagged(KeymanEngine.KeymanPackage.Key, Foundation.URL, FullID)
  }
  public typealias SelectionCompletedHandler<FullID> = (KeymanEngine.KeyboardSearchViewController.SearchResult<FullID>) -> Swift.Void where FullID : KeymanEngine.LanguageResourceFullID
  public typealias SearchDownloadHandler<FullID> = (KeymanEngine.KeyboardSearchViewController.SearchDownloadResult) -> Swift.Void where FullID : KeymanEngine.LanguageResourceFullID
  @_Concurrency.MainActor(unsafe) public init(languageCode: Swift.String? = nil, withSession session: Foundation.URLSession = URLSession.shared, keyboardSelectionBlock: @escaping KeymanEngine.KeyboardSearchViewController.SelectionCompletedHandler<KeymanEngine.FullKeyboardID>)
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func loadView()
  @_Concurrency.MainActor(unsafe) @objc public func webView(_ webView: WebKit.WKWebView, decidePolicyFor navigationAction: WebKit.WKNavigationAction, decisionHandler: @escaping (WebKit.WKNavigationActionPolicy) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) @objc public func webView(_ webView: WebKit.WKWebView, didFail navigation: WebKit.WKNavigation!, withError error: Swift.Error)
  @_Concurrency.MainActor(unsafe) @objc public func webView(_ webView: WebKit.WKWebView, didFailProvisionalNavigation navigation: WebKit.WKNavigation!, withError error: Swift.Error)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public static func defaultDownloadClosure(downloadCompletionBlock: @escaping KeymanEngine.KeyboardSearchViewController.SearchDownloadHandler<KeymanEngine.FullKeyboardID>) -> KeymanEngine.KeyboardSearchViewController.SelectionCompletedHandler<KeymanEngine.FullKeyboardID>
}
@_hasMissingDesignatedInitializers public class Colors {
  public static var popupBorder: UIKit.UIColor {
    get
  }
  public static var popupKey: UIKit.UIColor {
    get
  }
  public static var keyText: UIKit.UIColor {
    get
  }
  public static var popupKeyHighlighted: UIKit.UIColor {
    get
  }
  public static var popupKeyTint: UIKit.UIColor {
    get
  }
  public static var keyboardBackground: UIKit.UIColor {
    get
  }
  public static var keyboardSelectionPrimary: UIKit.UIColor {
    get
  }
  public static var helpBubbleGradient1: UIKit.UIColor {
    get
  }
  public static var helpBubbleGradient2: UIKit.UIColor {
    get
  }
  @objc deinit
}
public struct InstallableLexicalModel : Swift.Codable {
  public typealias Package = KeymanEngine.LexicalModelKeymanPackage
  public var id: Swift.String {
    get
  }
  public var packageID: Swift.String? {
    get
  }
  public var name: Swift.String
  public var version: Swift.String
  public var isCustom: Swift.Bool
  public var languageID: Swift.String {
    get
  }
  public var sharableURL: Swift.String? {
    get
  }
  public var typedFullID: KeymanEngine.FullLexicalModelID {
    get
  }
  public var fullID: KeymanEngine.FullLexicalModelID {
    get
  }
  public init(id: Swift.String, name: Swift.String, languageID: Swift.String, version: Swift.String, isCustom: Swift.Bool)
  public init(lexicalModel: KeymanEngine.LexicalModel, languageID: Swift.String, isCustom: Swift.Bool)
  public var fonts: [KeymanEngine.Font] {
    get
  }
  public var sourceFilename: Swift.String {
    get
  }
  public typealias FullID = KeymanEngine.FullLexicalModelID
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@available(*, deprecated, message: "Version checks against keyboards and models are now based on their package.  Use `KeymanPackage.InstallationState` and `KeymanPackage.VersionState` instead.")
public enum KeyboardState {
  case needsDownload
  case needsUpdate
  case upToDate
  case downloading
  case none
  public static func == (a: KeymanEngine.KeyboardState, b: KeymanEngine.KeyboardState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum VibrationSupport {
  case none
  case basic
  case basic_plus
  case taptic
  public static func == (a: KeymanEngine.VibrationSupport, b: KeymanEngine.VibrationSupport) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum SpacebarText : Swift.String {
  case LANGUAGE
  case KEYBOARD
  case LANGUAGE_KEYBOARD
  case BLANK
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class Manager : ObjectiveC.NSObject, UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) public static var applicationGroupIdentifier: Swift.String?
  @_Concurrency.MainActor(unsafe) public static let shared: KeymanEngine.Manager
  @_Concurrency.MainActor(unsafe) public var fileBrowserLauncher: ((UIKit.UINavigationController) -> Swift.Void)?
  @_Concurrency.MainActor(unsafe) public var isKeymanHelpOn: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var isSystemKeyboard: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) public var canAddNewKeyboards: Swift.Bool {
    get
    set(canAddNewKeyboards)
  }
  @_Concurrency.MainActor(unsafe) public var canRemoveKeyboards: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var canRemoveDefaultKeyboard: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var canAddNewLexicalModels: Swift.Bool {
    get
    set(canAddNewLexicalModels)
  }
  @_Concurrency.MainActor(unsafe) public var canRemoveLexicalModels: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var canRemoveDefaultLexicalModel: Swift.Bool
  @available(*, deprecated)
  @_Concurrency.MainActor(unsafe) public var openURL: ((Foundation.URL) -> Swift.Bool)?
  @_Concurrency.MainActor(unsafe) open var inputViewController: KeymanEngine.InputViewController! {
    get
    set(value)
  }
  @_Concurrency.MainActor(unsafe) public var spacebarText: KeymanEngine.SpacebarText {
    get
    set(value)
  }
  @_Concurrency.MainActor(unsafe) public func showKeymanEngineSettings(inVC: UIKit.UIViewController)
  @_Concurrency.MainActor(unsafe) public func setKeyboard(withFullID fullID: KeymanEngine.FullKeyboardID) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) public func setKeyboard(_ kb: KeymanEngine.InstallableKeyboard) -> Swift.Bool
  @available(*, deprecated, message: "Deprecated in favor of ResourceFileManager.install(resourceWithID:from:)")
  @_Concurrency.MainActor(unsafe) public func addKeyboard(_ keyboard: KeymanEngine.InstallableKeyboard)
  @_Concurrency.MainActor(unsafe) public func registerLexicalModel(withFullID fullID: KeymanEngine.FullLexicalModelID) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) public func addLexicalModel(lexicalModelId: Swift.String, languageId: Swift.String, from package: KeymanEngine.LexicalModelKeymanPackage) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) public func registerLexicalModel(lexicalModelId: Swift.String, languageId: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) public func registerLexicalModel(_ lm: KeymanEngine.InstallableLexicalModel) -> Swift.Bool
  @available(*, deprecated, message: "Deprecated in favor of ResourceFileManager.install(resourceWithID:from:)")
  @_Concurrency.MainActor(unsafe) public static func addLexicalModel(_ lexicalModel: KeymanEngine.InstallableLexicalModel)
  @_Concurrency.MainActor(unsafe) public func removeKeyboard(withFullID fullID: KeymanEngine.FullKeyboardID) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) public func removeKeyboard(at index: Swift.Int) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) public var currentKeyboard: KeymanEngine.InstallableKeyboard? {
    get
  }
  @_Concurrency.MainActor(unsafe) public func removeLexicalModel(lexicalModelId: Swift.String, languageId: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) public func removeLexicalModel(withFullID fullID: KeymanEngine.FullLexicalModelID) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) public func removeLexicalModelFromUserList(userDefs ud: Foundation.UserDefaults, at index: Swift.Int) -> KeymanEngine.InstallableLexicalModel?
  @_Concurrency.MainActor(unsafe) public func removeLexicalModelFromLanguagePreference(userDefs ud: Foundation.UserDefaults, _ lm: KeymanEngine.InstallableLexicalModel)
  @_Concurrency.MainActor(unsafe) public func removeLexicalModel(at index: Swift.Int) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) public var currentLexicalModel: KeymanEngine.InstallableLexicalModel? {
    get
  }
  @_Concurrency.MainActor(unsafe) public func switchToNextKeyboard() -> Swift.Int?
  @_Concurrency.MainActor(unsafe) public func fontNameForKeyboard(withFullID fullID: KeymanEngine.FullKeyboardID) -> Swift.String?
  @_Concurrency.MainActor(unsafe) public func fontPathForKeyboard(withFullID fullID: KeymanEngine.FullKeyboardID) -> Foundation.URL?
  @_Concurrency.MainActor(unsafe) public func parseKbdKMP(_ folder: Foundation.URL, isCustom: Swift.Bool) throws
  @_Concurrency.MainActor(unsafe) public static func parseLMKMP(_ folder: Foundation.URL, isCustom: Swift.Bool) throws
  @available(*, deprecated, message: "Use ResourceFileManager's methods to install resources from KMPs.")
  @_Concurrency.MainActor(unsafe) public func preloadFiles(forKeyboardID keyboardID: Swift.String, at urls: [Foundation.URL], shouldOverwrite: Swift.Bool) throws
  @_Concurrency.MainActor(unsafe) public func showKeyboardPicker(in viewController: UIKit.UIViewController, shouldAddKeyboard: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func dismissKeyboardPicker(_ viewController: UIKit.UIViewController)
  @_Concurrency.MainActor(unsafe) public func dismissLexicalModelPicker(_ viewController: UIKit.UIViewController)
  @_Concurrency.MainActor(unsafe) public func showKeyboard()
  @_Concurrency.MainActor(unsafe) public func hideKeyboard()
  @_Concurrency.MainActor(unsafe) public func downloadKeyboard(withID: Swift.String, languageID: Swift.String, isUpdate: Swift.Bool, fetchRepositoryIfNeeded: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) public func downloadLexicalModel(withID: Swift.String, languageID: Swift.String, isUpdate: Swift.Bool, fetchRepositoryIfNeeded: Swift.Bool = true)
  @available(*, deprecated)
  @_Concurrency.MainActor(unsafe) public func stateForKeyboard(withID keyboardID: Swift.String) -> KeymanEngine.KeyboardState
  @available(*, deprecated)
  @_Concurrency.MainActor(unsafe) public func stateForLexicalModel(withID modelID: Swift.String) -> KeymanEngine.KeyboardState
  @_Concurrency.MainActor(unsafe) public func parseKMP(_ folder: Foundation.URL, type: KeymanEngine.LanguageResourceType = .keyboard, isCustom: Swift.Bool) throws
  @_Concurrency.MainActor(unsafe) public func keyboardHeight() -> CoreFoundation.CGFloat
  @objc deinit
}
public class LanguagePickAssociator {
  public enum Progress {
    case cancelled
    case inProgress(Swift.Int, Swift.Int)
    case complete(Swift.Int, KeymanEngine.LanguagePickAssociator.AssociationMap)
  }
  public typealias AssociationSearcher = (Swift.Set<Swift.String>, @escaping ([Swift.String : (KeymanEngine.KeymanPackage.Key, Foundation.URL)?]) -> Swift.Void) -> Swift.Void
  public typealias AssociationReceiver = (KeymanEngine.LanguagePickAssociator.Progress) -> Swift.Void
  public typealias AssociationMap = [KeymanEngine.KeymanPackage.Key : KeymanEngine.LanguagePickAssociator.Association]
  public struct Association {
    public let url: Foundation.URL
    public let languageCodes: Swift.Set<Swift.String>
  }
  public static let lexicalModelSearcher: KeymanEngine.LanguagePickAssociator.AssociationSearcher
  public init(searchWith searcher: @escaping KeymanEngine.LanguagePickAssociator.AssociationSearcher, progressClosure: @escaping KeymanEngine.LanguagePickAssociator.AssociationReceiver)
  @objc deinit
  public func pickerInitialized()
  public func selectLanguages(_ languages: Swift.Set<Swift.String>)
  public func deselectLanguages(_ languages: Swift.Set<Swift.String>)
  public func pickerDismissed()
  public func pickerFinalized()
  public var languagesPicked: Swift.Int {
    get
  }
  public var languagesQueried: Swift.Int {
    get
  }
}
public class NotificationObserver {
  public init(observer: ObjectiveC.NSObjectProtocol, center: Foundation.NotificationCenter)
  @objc deinit
}
extension Foundation.UserDefaults {
  public func installableKeyboards(forKey key: Swift.String) -> [KeymanEngine.InstallableKeyboard]?
  public func installableLexicalModels(forKey key: Swift.String) -> [KeymanEngine.InstallableLexicalModel]?
  public func set(_ keyboards: [KeymanEngine.InstallableKeyboard]?, forKey key: Swift.String)
  public func set(_ lexicalModels: [KeymanEngine.InstallableLexicalModel]?, forKey key: Swift.String)
  public func fullKeyboardID(forKey key: Swift.String) -> KeymanEngine.FullKeyboardID?
  public func set(_ fullKeyboardID: KeymanEngine.FullKeyboardID?, forKey key: Swift.String)
  public func fullLexicalModelID(forKey key: Swift.String) -> KeymanEngine.FullLexicalModelID?
  public func set(_ fullLexicalModelID: KeymanEngine.FullLexicalModelID?, forKey key: Swift.String)
  public var userKeyboards: [KeymanEngine.InstallableKeyboard]? {
    get
    set(keyboards)
  }
  public var userLexicalModels: [KeymanEngine.InstallableLexicalModel]? {
    get
    set(lexicalModels)
  }
  public func userResources<Resource>(ofType: Resource.Type) -> [Resource]? where Resource : KeymanEngine.LanguageResource
  public var userResources: [KeymanEngine.AnyLanguageResource]? {
    get
  }
  public var languageModelSelections: [Swift.String : Swift.String]? {
    get
    set(lexicalModelPrefs)
  }
  public func preferredLexicalModelID(forLanguage lgCode: Swift.String) -> Swift.String?
  public func set(preferredLexicalModelID: Swift.String?, forKey key: Swift.String)
  public var currentKeyboardID: KeymanEngine.FullKeyboardID? {
    get
    set(fullKeyboardID)
  }
  public var currentLexicalModelID: KeymanEngine.FullLexicalModelID? {
    get
    set(fullLexicalModelID)
  }
  public func userKeyboard(withFullID fullID: KeymanEngine.FullKeyboardID) -> KeymanEngine.InstallableKeyboard?
  public func userLexicalModel(withFullID fullID: KeymanEngine.FullLexicalModelID) -> KeymanEngine.InstallableLexicalModel?
  public func userLexicalModelsForLanguage(languageID: Swift.String) -> [KeymanEngine.InstallableLexicalModel]?
  public var migrationLevel: Swift.Int {
    get
    set(level)
  }
  public var lastEngineVersion: KeymanEngine.Version? {
    get
    set(version)
  }
  public var optSpacebarText: KeymanEngine.SpacebarText {
    get
    set(value)
  }
  public var predictionEnablements: [Swift.String : Swift.Bool]? {
    get
    set(prefs)
  }
  public var correctionEnablements: [Swift.String : Swift.Bool]? {
    get
    set(prefs)
  }
  public func predictSettingForLanguage(languageID: Swift.String) -> Swift.Bool
  public func set(predictSetting: Swift.Bool, forLanguageID: Swift.String)
  public func correctSettingForLanguage(languageID: Swift.String) -> Swift.Bool
  public func set(correctSetting: Swift.Bool, forLanguageID: Swift.String)
}
public enum DownloadError : Swift.Error {
  public enum Cause : Swift.Error {
    case error(Swift.Error)
    case responseCode(Swift.Int, Swift.String, Foundation.URL)
  }
  case failed(KeymanEngine.DownloadError.Cause)
  case busy
  case noInternet
}
public enum UpdateError : Swift.Error {
  public enum Cause : Swift.Error {
    case error(Swift.Error)
    case responseCode(Swift.Int, Swift.String, Foundation.URL)
  }
  case unmanaged
  case sourceUnavailable
  public static func == (a: KeymanEngine.UpdateError, b: KeymanEngine.UpdateError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ResourceDownloadManager {
  public static let DISTRIBUTION_CACHE_VALIDITY_THRESHOLD: Foundation.TimeInterval
  public typealias CompletionHandler<Package> = (Package?, Swift.Error?) throws -> Swift.Void where Package : KeymanEngine.KeymanPackage
  public typealias BatchCompletionHandler = () -> Swift.Void
  public static let shared: KeymanEngine.ResourceDownloadManager
  public func defaultDownloadURL(forPackage packageKey: KeymanEngine.KeymanPackage.Key, andResource resourceKey: KeymanEngine.AnyLanguageResourceFullID? = nil, withVersion version: KeymanEngine.Version? = nil, asUpdate: Swift.Bool? = nil) -> Foundation.URL
  public func downloadKeyboard(withID keyboardID: Swift.String, languageID: Swift.String, isUpdate: Swift.Bool, fetchRepositoryIfNeeded: Swift.Bool = true, completionBlock: KeymanEngine.ResourceDownloadManager.CompletionHandler<KeymanEngine.KeyboardKeymanPackage>? = nil)
  @available(*, deprecated, message: "Use `ResourceFileManager.shared.installState(forPackage:)` instead.  Keyboard states are now tied to the state of their package.")
  public func stateForKeyboard(withID keyboardID: Swift.String) -> KeymanEngine.KeyboardState
  public func downloadLexicalModelsForLanguageIfExists(languageID: Swift.String, completionClosure: KeymanEngine.ResourceDownloadManager.CompletionHandler<KeymanEngine.LexicalModelKeymanPackage>? = nil)
  public func downloadLexicalModel(withID lexicalModelID: Swift.String, languageID: Swift.String, isUpdate: Swift.Bool, fetchRepositoryIfNeeded: Swift.Bool = true, completionBlock: KeymanEngine.ResourceDownloadManager.CompletionHandler<KeymanEngine.LexicalModelKeymanPackage>? = nil)
  @available(*, deprecated, message: "Use `ResourceFileManager.shared.installState(forPackage:)` instead.  Lexical model states are tied to the state of their package.")
  public func stateForLexicalModel(withID lexicalModelID: Swift.String) -> KeymanEngine.KeyboardState
  public func downloadPackage<Package>(withKey packageKey: KeymanEngine.KeymanPackage.Key, from url: Foundation.URL, withNotifications: Swift.Bool = false, completionBlock: @escaping KeymanEngine.ResourceDownloadManager.CompletionHandler<Package>) where Package : KeymanEngine.KeymanPackage
  public var updateCacheIsCurrent: Swift.Bool {
    get
  }
  public var updatesAvailable: Swift.Bool {
    get
  }
  public func getKeysForUpdatablePackages() -> Swift.Set<KeymanEngine.KeymanPackage.Key>
  public func queryKeysForUpdatablePackages(completionBlock: @escaping (Swift.Set<KeymanEngine.KeymanPackage.Key>?, Swift.Error?) -> Swift.Void)
  public func performBatchUpdate(forPackageKeys keysToUpdate: Swift.Set<KeymanEngine.KeymanPackage.Key>? = nil, withNotifications: Swift.Bool = true, completionBlock: (([KeymanEngine.KeymanPackage.Key], [(KeymanEngine.KeymanPackage.Key, Swift.Error)]) -> Swift.Void)? = nil)
  @available(*, deprecated)
  public func installLexicalModelPackage(at packageURL: Foundation.URL) -> KeymanEngine.InstallableLexicalModel?
  public func standardKeyboardInstallCompletionBlock(forFullID fullID: KeymanEngine.FullKeyboardID, withModel: Swift.Bool = true) -> KeymanEngine.ResourceDownloadManager.CompletionHandler<KeymanEngine.KeyboardKeymanPackage>
  public func standardLexicalModelInstallCompletionBlock(forFullID fullID: KeymanEngine.FullLexicalModelID) -> KeymanEngine.ResourceDownloadManager.CompletionHandler<KeymanEngine.LexicalModelKeymanPackage>
  public func downloadRawKMP(from url: Foundation.URL, handler: @escaping (Foundation.URL?, Swift.Error?) -> Swift.Void)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class UniversalLinks {
  public struct ParsedKeyboardInstallLink {
    public let keyboard_id: Swift.String
    public let lang_id: Swift.String?
    public var packageKey: KeymanEngine.KeymanPackage.Key {
      get
    }
  }
  public static var externalLinkLauncher: ((Foundation.URL) -> Swift.Void)?
  public static func tryParseKeyboardInstallLink(_ link: Foundation.URL) -> KeymanEngine.UniversalLinks.ParsedKeyboardInstallLink?
  public static func isExternalLink(_ link: Foundation.URL) -> Swift.Bool
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Queries {
  public enum FetchError : Foundation.LocalizedError {
    case networkError(Swift.Error)
    case noData
    case parsingError(Swift.Error)
    case decodingError(Swift.String, Swift.String)
  }
  public enum ResultError : Foundation.LocalizedError {
    case unqueried
    public static func == (a: KeymanEngine.Queries.ResultError, b: KeymanEngine.Queries.ResultError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public typealias JSONQueryCompletionBlock<T> = (T?, KeymanEngine.Queries.FetchError?) -> Swift.Void where T : Swift.Decodable
  @objc deinit
}
extension KeymanEngine.Queries {
  @_hasMissingDesignatedInitializers public class LexicalModel {
    public struct Result : Swift.Decodable {
      public init(from decoder: Swift.Decoder) throws
    }
    public static func fetch(forLanguageCode bcp47: Swift.String, fetchCompletion: @escaping KeymanEngine.Queries.JSONQueryCompletionBlock<[KeymanEngine.Queries.LexicalModel.Result]>)
    public static func fetchModels(forLanguageCode bcp47: Swift.String, fetchCompletion: @escaping ([(KeymanEngine.InstallableLexicalModel, Foundation.URL)]?, Swift.Error?) -> Swift.Void)
    @objc deinit
  }
}
public protocol TextViewDelegate : UIKit.UITextViewDelegate {
}
@_hasMissingDesignatedInitializers public class FontManager {
  public static let shared: KeymanEngine.FontManager
  public var fonts: [Foundation.URL : KeymanEngine.RegisteredFont] {
    get
  }
  public func fontName(at url: Foundation.URL) -> Swift.String?
  public func registerCustomFonts()
  public func unregisterCustomFonts()
  public func registerFont(at url: Foundation.URL) -> Swift.Bool
  public func unregisterFont(at url: Foundation.URL, fromSystemOnly: Swift.Bool = true) -> Swift.Bool
  public func registerFonts(in directory: Foundation.URL)
  public func unregisterFonts(in directory: Foundation.URL, fromSystemOnly: Swift.Bool = true)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SentryManager {
  public static var hasStarted: Swift.Bool {
    get
  }
  public static func start(sendingEnabled: Swift.Bool = true)
  public static func altEnabled() -> Swift.Bool
  public static var enabled: Swift.Bool {
    get
    set(flag)
  }
  public static func captureAndLog(_ event: Sentry.Event, logLevel: XCGLogger.XCGLogger.Level? = nil)
  public static func captureAndLog(_ error: Swift.Error, message: Swift.String? = nil, sentryLevel: Sentry.SentryLevel = .error, logLevel: XCGLogger.XCGLogger.Level? = nil)
  public static func captureAndLog(_ message: Swift.String, sentryLevel: Sentry.SentryLevel = .error, logLevel: XCGLogger.XCGLogger.Level? = nil)
  public static func breadcrumbAndLog(crumb: Sentry.Breadcrumb, logLevel: XCGLogger.XCGLogger.Level? = nil)
  public static func breadcrumbAndLog(_ message: Swift.String, category: Swift.String? = nil, sentryLevel: Sentry.SentryLevel = .info, logLevel: XCGLogger.XCGLogger.Level? = nil)
  public static func forceError()
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class KeyboardKeymanPackage : KeymanEngine.TypedKeymanPackage<KeymanEngine.InstallableKeyboard> {
  override public func defaultInfoHtml() -> Swift.String
  @objc deinit
}
@available(*, deprecated, message: "Download notifications are now package-based.  Use `PackageDownloadStartedNotification` instead.")
public typealias KeyboardDownloadStartedNotification = [KeymanEngine.InstallableKeyboard]
@available(*, deprecated, message: "Download notifications are now package-based.  Use `PackageDownloadCompletedNotification` instead.")
public typealias KeyboardDownloadCompletedNotification = [KeymanEngine.InstallableKeyboard]
@available(*, deprecated, message: "Download notifications are now package-based.  Use `PackageDownloadFailedNotification` instead.")
public struct KeyboardDownloadFailedNotification {
  public let keyboards: [KeymanEngine.InstallableKeyboard]
  public let error: Swift.Error
}
@available(*, deprecated, message: "Download notifications are now package-based.  Use `PackageDownloadStartedNotification` instead.")
public typealias LexicalModelDownloadStartedNotification = [KeymanEngine.InstallableLexicalModel]
@available(*, deprecated, message: "Download notifications are now package-based.  Use `PackageDownloadCompletedNotification` instead.")
public typealias LexicalModelDownloadCompletedNotification = [KeymanEngine.InstallableLexicalModel]
@available(*, deprecated, message: "Download notifications are now package-based.  Use `PackageDownloadFailedNotification` instead.")
public struct LexicalModelDownloadFailedNotification {
  public let lmOrLanguageID: Swift.String
  public let error: Swift.Error
}
public typealias PackageDownloadStartedNotification = KeymanEngine.KeymanPackage.Key
public typealias PackageDownloadCompletedNotification = KeymanEngine.KeymanPackage
public struct PackageDownloadFailedNotification {
  public let packageKey: KeymanEngine.KeymanPackage.Key?
  public let error: Swift.Error
}
public typealias BatchUpdateStartedNotification = [KeymanEngine.AnyLanguageResource]
public struct BatchUpdateCompletedNotification {
  public let successes: [KeymanEngine.KeymanPackage.Key]
  public let failures: [(KeymanEngine.KeymanPackage.Key, Swift.Error)]
}
public typealias KeyboardLoadedNotification = KeymanEngine.InstallableKeyboard
public typealias KeyboardChangedNotification = KeymanEngine.InstallableKeyboard
public typealias KeyboardRemovedNotification = KeymanEngine.InstallableKeyboard
public typealias KeyboardPickerDismissedNotification = Swift.Void
public typealias LexicalModelLoadedNotification = KeymanEngine.InstallableLexicalModel
public typealias LexicalModelChangedNotification = KeymanEngine.InstallableLexicalModel
public typealias LexicalModelRemovedNotification = KeymanEngine.InstallableLexicalModel
public typealias LexicalModelPickerDismissedNotification = Swift.Void
public struct Notifications {
  public static let packageDownloadStarted: KeymanEngine.NotificationName<KeymanEngine.PackageDownloadStartedNotification>
  public static let packageDownloadCompleted: KeymanEngine.NotificationName<KeymanEngine.PackageDownloadCompletedNotification>
  public static let packageDownloadFailed: KeymanEngine.NotificationName<KeymanEngine.PackageDownloadFailedNotification>
  @available(swift, deprecated: 0.1, obsoleted: 0.1, renamed: "packageDownloadStarted", message: "Download notifications are now package-based.  Use `packageDownloadStarted` instead.")
  public static let keyboardDownloadStarted: KeymanEngine.NotificationName<KeymanEngine.KeyboardDownloadStartedNotification>
  @available(swift, deprecated: 0.1, obsoleted: 0.1, renamed: "packageDownloadCompleted", message: "Download notifications are now package-based.  Use `packageDownloadCompleted` instead.")
  public static let keyboardDownloadCompleted: KeymanEngine.NotificationName<KeymanEngine.KeyboardDownloadCompletedNotification>
  @available(swift, deprecated: 0.1, obsoleted: 0.1, renamed: "packageDownloadFailed", message: "Download notifications are now package-based.  Use `packageDownloadFailed` instead.")
  public static let keyboardDownloadFailed: KeymanEngine.NotificationName<KeymanEngine.KeyboardDownloadFailedNotification>
  public static let keyboardLoaded: KeymanEngine.NotificationName<KeymanEngine.KeyboardLoadedNotification>
  public static let keyboardChanged: KeymanEngine.NotificationName<KeymanEngine.KeyboardChangedNotification>
  public static let keyboardRemoved: KeymanEngine.NotificationName<KeymanEngine.KeyboardRemovedNotification>
  public static let keyboardPickerDismissed: KeymanEngine.NotificationName<KeymanEngine.KeyboardPickerDismissedNotification>
  @available(swift, deprecated: 0.1, obsoleted: 0.1, renamed: "packageDownloadStarted", message: "Download notifications are now package-based.  Use `packageDownloadStarted` instead.")
  public static let lexicalModelDownloadStarted: KeymanEngine.NotificationName<KeymanEngine.LexicalModelDownloadStartedNotification>
  @available(swift, deprecated: 0.1, obsoleted: 0.1, renamed: "packageDownloadCompleted", message: "Download notifications are now package-based.  Use `packageDownloadCompleted` instead.")
  public static let lexicalModelDownloadCompleted: KeymanEngine.NotificationName<KeymanEngine.LexicalModelDownloadCompletedNotification>
  @available(swift, deprecated: 0.1, obsoleted: 0.1, renamed: "packageDownloadFailed", message: "Download notifications are now package-based.  Use `packageDownloadFailed` instead.")
  public static let lexicalModelDownloadFailed: KeymanEngine.NotificationName<KeymanEngine.LexicalModelDownloadFailedNotification>
  public static let lexicalModelLoaded: KeymanEngine.NotificationName<KeymanEngine.LexicalModelLoadedNotification>
  public static let lexicalModelChanged: KeymanEngine.NotificationName<KeymanEngine.LexicalModelChangedNotification>
  public static let lexicalModelRemoved: KeymanEngine.NotificationName<KeymanEngine.LexicalModelRemovedNotification>
  public static let lexicalModelPickerDismissed: KeymanEngine.NotificationName<KeymanEngine.LexicalModelPickerDismissedNotification>
  public static let batchUpdateStarted: KeymanEngine.NotificationName<KeymanEngine.BatchUpdateStartedNotification>
  public static let batchUpdateCompleted: KeymanEngine.NotificationName<KeymanEngine.BatchUpdateCompletedNotification>
}
@objc @_Concurrency.MainActor(unsafe) public class KeyboardPickerButton : UIKit.UIButton {
  @_Concurrency.MainActor(unsafe) public init(presentingVC: UIKit.UIViewController)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func setTitle(_ title: Swift.String?, for state: UIKit.UIControl.State)
}
@_hasMissingDesignatedInitializers open class Alerts {
  public typealias AcceptanceHandler = ((UIKit.UIAlertAction)) -> Swift.Void
  public static func constructActivitySpinner() -> UIKit.UIActivityIndicatorView
  public static func showErrorAlert(in vc: UIKit.UIViewController, title: Swift.String, msg: Swift.String, handler: @escaping KeymanEngine.Alerts.AcceptanceHandler)
  public static func showConnectionErrorAlert(in vc: UIKit.UIViewController, handler: @escaping KeymanEngine.Alerts.AcceptanceHandler)
  public static func showDownloadErrorAlert(in vc: UIKit.UIViewController, handler: @escaping KeymanEngine.Alerts.AcceptanceHandler)
  public static func popToNavigationRootHandler(for vc: UIKit.UIViewController) -> KeymanEngine.Alerts.AcceptanceHandler
  @objc deinit
}
public struct RegisteredFont {
  public let name: Swift.String
  public var isRegistered: Swift.Bool
  public init(name: Swift.String, isRegistered: Swift.Bool)
}
public struct Language : Swift.Codable {
  public let name: Swift.String
  public let id: Swift.String
  public let keyboards: [KeymanEngine.Keyboard]?
  public let lexicalModels: [KeymanEngine.LexicalModel]?
  public let font: KeymanEngine.Font?
  public let oskFont: KeymanEngine.Font?
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class PackageInstallViewController<Resource> : UIKit.UIViewController, UIKit.UITableViewDelegate, UIKit.UITableViewDataSource, UIKit.UITabBarControllerDelegate, UIKit.UIAdaptivePresentationControllerDelegate where Resource : KeymanEngine.LanguageResource {
  public typealias CompletionHandler = ([Resource.FullID]?) -> Swift.Void
  @_Concurrency.MainActor(unsafe) public init(for package: Resource.Package, defaultLanguageCode: Swift.String? = nil, languageAssociators: [KeymanEngine.LanguagePickAssociator] = [], pickingCompletionHandler: @escaping KeymanEngine.PackageInstallViewController<Resource>.CompletionHandler, uiCompletionHandler: @escaping (() -> Swift.Void))
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc public func tabBarController(_ tabBarController: UIKit.UITabBarController, shouldSelect viewController: UIKit.UIViewController) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc public func tabBarController(_ tabBarController: UIKit.UITabBarController, didSelect item: UIKit.UIViewController)
  @_Concurrency.MainActor(unsafe) @objc public func presentationControllerDidDismiss(_ presentationController: UIKit.UIPresentationController)
  @_Concurrency.MainActor(unsafe) @objc public func tableView(_ tableView: UIKit.UITableView, titleForHeaderInSection: Swift.Int) -> Swift.String?
  @_Concurrency.MainActor(unsafe) @objc public func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc public func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @_Concurrency.MainActor(unsafe) @objc public func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc public func tableView(_ tableView: UIKit.UITableView, didDeselectRowAt indexPath: Foundation.IndexPath)
  @objc deinit
}
@objc @_Concurrency.MainActor(unsafe) public class KeyboardPickerBarButtonItem : UIKit.UIBarButtonItem {
  @_Concurrency.MainActor(unsafe) public init(presentingVC: UIKit.UIViewController)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var title: Swift.String? {
    @objc get
    @objc set(title)
  }
}
@objc @_Concurrency.MainActor(unsafe) open class SpacebarTextViewController : UIKit.UITableViewController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class InstalledLanguagesViewController : UIKit.UITableViewController, UIKit.UIAlertViewDelegate {
  @_Concurrency.MainActor(unsafe) public init(_ givenLanguages: [Swift.String : KeymanEngine.Language]? = nil)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func loadView()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func numberOfSections(in tableView: UIKit.UITableView) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func sectionIndexTitles(for tableView: UIKit.UITableView) -> [Swift.String]
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func tableView(_ tableView: UIKit.UITableView, sectionForSectionIndexTitle title: Swift.String, at index: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func tableView(_ tableView: UIKit.UITableView, willDisplay cell: UIKit.UITableViewCell, forRowAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func tableView(_ tableView: UIKit.UITableView, accessoryButtonTappedForRowWith indexPath: Foundation.IndexPath)
  @objc deinit
}
extension KeymanEngine.InstalledLanguagesViewController {
  @_Concurrency.MainActor(unsafe) public func launchKeyboardSearch()
}
public enum KeymanHosts {
  public static var API_KEYMAN_COM: Foundation.URL {
    get
  }
  public static var HELP_KEYMAN_COM: Foundation.URL {
    get
  }
  public static var KEYMAN_COM: Foundation.URL {
    get
  }
}
public struct FullKeyboardID : Swift.Codable, KeymanEngine.LanguageResourceFullID, Swift.Equatable {
  public typealias Resource = KeymanEngine.InstallableKeyboard
  public var keyboardID: Swift.String
  public var languageID: Swift.String
  public var id: Swift.String {
    get
  }
  public var type: KeymanEngine.LanguageResourceType {
    get
  }
  public init(keyboardID: Swift.String, languageID: Swift.String)
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension KeymanEngine.FullKeyboardID : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@available(swift, deprecated: 0.1, obsoleted: 0.1, message: "APIKeyboardRepository and associated types have been obsoleted in favor of keyboard search and package-oriented queries.")
public enum APIKeyboardFetchError : Swift.Error {
}
@_hasMissingDesignatedInitializers @available(swift, deprecated: 0.1, obsoleted: 0.1, message: "APIKeyboardRepository and associated types have been obsoleted in favor of keyboard search and package-oriented queries.  If necessary, queries may be built against our api.keyman.com/search endpoint as documented at https://help.keyman.com/developer/cloud/search/1.0/")
public class APIKeyboardRepository {
  @objc deinit
}
@available(swift, deprecated: 0.1, obsoleted: 0.1, message: "APIKeyboardRepository and associated types have been obsoleted in favor of keyboard search and package-oriented queries.")
public protocol KeyboardRepository : AnyObject {
}
@available(swift, deprecated: 0.1, obsoleted: 0.1, message: "APIKeyboardRepository and associated types have been obsoleted in favor of keyboard search and package-oriented queries.")
public protocol KeyboardRepositoryDelegate : AnyObject {
}
@available(swift, deprecated: 0.1, obsoleted: 0.1, message: "APILexicalModelRepository and associated types have been obsoleted by `Queries.LexicalModel` and its `fetch` variants.")
public protocol LexicalModelRepository {
}
@available(swift, deprecated: 0.1, obsoleted: 0.1, message: "APILexicalModelRepository and associated types have been obsoleted by `Queries.LexicalModel` and its `fetch` variants.")
public enum APILexicalModelFetchError : Swift.Error {
}
@_hasMissingDesignatedInitializers @available(swift, deprecated: 0.1, obsoleted: 0.1, message: "APILexicalModelRepository and associated types have been obsoleted by `Queries.LexicalModel` and its `fetch` variants.")
public class APILexicalModelRepository {
  @objc deinit
}
@available(swift, deprecated: 0.1, obsoleted: 0.1, message: "APILexicalModelRepository and associated types have been obsoleted by `Queries.LexicalModel` and its `fetch` variants.")
public protocol LexicalModelRepositoryDelegate : AnyObject {
}
@available(swift, deprecated: 0.1, obsoleted: 0.1, message: "This type is no longer utilized by KeymanEngine, as the related API methods have all been obsoleted.")
public struct Options : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class TextField : UIKit.UITextField, KeymanEngine.KeymanResponder {
  @_Concurrency.MainActor(unsafe) public var viewController: UIKit.UIViewController?
  @_Concurrency.MainActor(unsafe) public var shouldSetCustomFontOnKeyboardChange: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var isInputClickSoundEnabled: Swift.Bool
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc convenience dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var inputViewController: UIKit.UIInputViewController? {
    @objc get
    @objc set(inputViewController)
  }
  @_Concurrency.MainActor(unsafe) @objc override weak dynamic public var delegate: UIKit.UITextFieldDelegate? {
    @objc get
    @objc set(delegate)
  }
  @_Concurrency.MainActor(unsafe) public func setKeymanDelegate(_ keymanDelegate: KeymanEngine.TextFieldDelegate?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var text: Swift.String! {
    @objc get
    @objc set(text)
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var selectedTextRange: UIKit.UITextRange? {
    @objc get
    @objc set
  }
}
extension KeymanEngine.KeymanResponder where Self : KeymanEngine.TextField {
  public func dismissKeyboard()
  public func summonKeyboard()
  public func showKeyboardPicker() -> Swift.Bool
}
extension KeymanEngine.TextField : UIKit.UITextFieldDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textField(_ textField: UIKit.UITextField, shouldChangeCharactersIn range: Foundation.NSRange, replacementString string: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldShouldClear(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldShouldBeginEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldDidBeginEditing(_ textField: UIKit.UITextField)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldShouldEndEditing(_ textField: UIKit.UITextField) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class ResourceFileManager {
  public static let shared: KeymanEngine.ResourceFileManager
  public var installedPackages: [KeymanEngine.KeymanPackage] {
    get
  }
  public func installState(forPackage key: KeymanEngine.KeymanPackage.Key) -> KeymanEngine.KeymanPackage.InstallationState
  public func getInstalledPackage<Resource>(for resource: Resource) -> Resource.Package? where Resource : KeymanEngine.LanguageResource
  public func getInstalledPackage(withKey key: KeymanEngine.KeymanPackage.Key) -> KeymanEngine.KeymanPackage?
  public func importFile(_ url: Foundation.URL) -> Foundation.URL?
  public func prepareKMPInstall(from url: Foundation.URL) throws -> KeymanEngine.KeymanPackage
  @available(*, deprecated)
  public func prepareKMPInstall(from url: Foundation.URL, completionHandler: @escaping (KeymanEngine.KeymanPackage?, Swift.Error?) -> Swift.Void)
  @available(*, deprecated)
  public func prepareKMPInstall(from url: Foundation.URL, alertHost: UIKit.UIViewController, completionHandler: @escaping (KeymanEngine.KeymanPackage) -> Swift.Void)
  public func prepareKMPInstall(from url: Foundation.URL, alertHost: UIKit.UIViewController) -> KeymanEngine.KeymanPackage?
  public func promptPackageInstall(of package: KeymanEngine.KeymanPackage, in rootVC: UIKit.UIViewController, isCustom: Swift.Bool, successHandler: ((KeymanEngine.KeymanPackage) -> Swift.Void)? = nil)
  public func buildKMPError(_ error: KeymanEngine.KMPError) -> UIKit.UIAlertController
  public func buildSimpleAlert(title: Swift.String, message: Swift.String, completionHandler: (() -> Swift.Void)? = nil) -> UIKit.UIAlertController
  public func finalizePackageInstall(_ package: KeymanEngine.KeymanPackage, isCustom: Swift.Bool) throws
  @available(*, deprecated)
  public func finalizePackageInstall(_ package: KeymanEngine.KeymanPackage, isCustom: Swift.Bool, completionHandler: (Swift.Error?) -> Swift.Void)
  public func install<FullID>(resourceWithID fullID: FullID, from package: FullID.Resource.Package) throws where FullID : KeymanEngine.LanguageResourceFullID, FullID.Resource.Package : KeymanEngine.TypedKeymanPackage<FullID.Resource>
  public func install<FullID>(resourcesWithIDs fullIDs: [FullID], from package: FullID.Resource.Package) throws where FullID : KeymanEngine.LanguageResourceFullID, FullID.Resource.Package : KeymanEngine.TypedKeymanPackage<FullID.Resource>
  @objc deinit
}
public protocol TextFieldDelegate : UIKit.UITextFieldDelegate {
}
public enum KMPError : Swift.String, Swift.Error {
  case noMetadata
  case invalidPackage
  case fileSystem
  case copyFiles
  case unsupportedPackage
  case doesNotExist
  case wrongPackageType
  case resourceNotInPackage
  case unsupportedKeymanVersion
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum KeymanPackagePage {
  case welcome
  case readme
  case custom(bundledPath: Swift.String)
}
@_hasMissingDesignatedInitializers public class KeymanPackage {
  public struct Key : Swift.Hashable, Swift.Codable {
    public static func == (lhs: KeymanEngine.KeymanPackage.Key, rhs: KeymanEngine.KeymanPackage.Key) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public enum DistributionMethod : Swift.String, Swift.Codable {
    case unknown
    case cloudDeprecated
    case cloud
    case custom
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum VersionState : Swift.String, Swift.Codable {
    case unknown
    case upToDate
    case needsUpdate
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum InstallationState : Swift.String, Swift.Codable {
    case none
    case downloading
    case pending
    case installed
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct DistributionStateMetadata : Swift.Codable {
    public func encode(to encoder: Swift.Encoder) throws
    public init(from decoder: Swift.Decoder) throws
  }
  final public let sourceFolder: Foundation.URL
  final public let id: Swift.String
  @objc deinit
  public var key: KeymanEngine.KeymanPackage.Key {
    get
  }
  public var name: Swift.String {
    get
  }
  public func isKeyboard() -> Swift.Bool
  public var distributionMethod: KeymanEngine.KeymanPackage.DistributionMethod {
    get
  }
  public var installState: KeymanEngine.KeymanPackage.InstallationState {
    get
  }
  public var versionState: KeymanEngine.KeymanPackage.VersionState {
    get
  }
  public func resourceType() -> KeymanEngine.LanguageResourceType
  public func defaultInfoHtml() -> Swift.String
  public func infoHtml() -> Swift.String
  public func pageURL(for page: KeymanEngine.KeymanPackagePage) -> Foundation.URL?
  public var version: KeymanEngine.Version {
    get
  }
  public var installableResourceSets: [[KeymanEngine.AnyLanguageResource]] {
    get
  }
  public func installableResources(forLanguage lgCode: Swift.String) -> [KeymanEngine.AnyLanguageResource]
  public static func parse(_ folder: Foundation.URL) throws -> KeymanEngine.KeymanPackage?
  @available(*, deprecated, message: "Use of the completion block is unnecessary; this method now returns synchronously.")
  public static func extract(fileUrl: Foundation.URL, destination: Foundation.URL, complete: @escaping (KeymanEngine.KeymanPackage?) -> Swift.Void) throws
  public static func clearDirectory(destination: Foundation.URL) throws
  public static func extract(fileUrl: Foundation.URL, destination: Foundation.URL) throws -> KeymanEngine.KeymanPackage?
  public static func unzipFile(fileUrl: Foundation.URL, destination: Foundation.URL, complete: @escaping () -> Swift.Void = {}) throws
  public static func queryDistributionStates(for keys: [KeymanEngine.KeymanPackage.Key], withSession session: Foundation.URLSession = URLSession.shared, completionBlock: (([KeymanEngine.KeymanPackage.Key : KeymanEngine.KeymanPackage.DistributionStateMetadata]?, Swift.Error?) -> Swift.Void)? = nil)
  public static func queryCurrentVersions(for keys: [KeymanEngine.KeymanPackage.Key], withSession session: Foundation.URLSession = URLSession.shared, completionBlock: (([KeymanEngine.KeymanPackage.Key : KeymanEngine.Version]?, Swift.Error?) -> Swift.Void)? = nil)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class TypedKeymanPackage<TypedLanguageResource> : KeymanEngine.KeymanPackage where TypedLanguageResource : KeymanEngine.LanguageResource {
  public var installables: [[TypedLanguageResource]] {
    get
  }
  override public var installableResourceSets: [[KeymanEngine.AnyLanguageResource]] {
    get
  }
  public func installables(forLanguage lgCode: Swift.String) -> [TypedLanguageResource]
  public func findResource(withID fullID: TypedLanguageResource.FullID) -> TypedLanguageResource?
  public var languages: [KeymanEngine.Language] {
    get
  }
  @objc deinit
}
public struct LexicalModel : Swift.Codable {
  public var id: Swift.String
  public var name: Swift.String
  public var license: Swift.String?
  public var version: Swift.String?
  public var languages: [Swift.String]
  public var authorName: Swift.String?
  public var fileSize: Swift.Int?
  public var filename: Swift.String
  public var sourcePath: Swift.String?
  public var authorEmail: Swift.String?
  public var description: Swift.String?
  public var packageFileSize: Swift.Int?
  public var packageFilename: Swift.String
  public var packageIncludes: [Swift.String]?
  public var isDefault: Swift.Bool?
  public var lastModifiedDate: Foundation.Date?
  public var minKeymanVersion: Swift.String?
  public init(id: Swift.String, name: Swift.String, license: Swift.String?, version: Swift.String?, languages: [Swift.String], authorName: Swift.String?, fileSize: Swift.Int?, filename: Swift.String, sourcePath: Swift.String?, authorEmail: Swift.String?, description: Swift.String?, packageFileSize: Swift.Int?, packageFilename: Swift.String, packageIncludes: [Swift.String]?, isDefault: Swift.Bool?, lastModified: Foundation.Date?, minKeymanVersion: Swift.String?)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers public class AssociatingPackageInstaller<Resource, Package> where Resource : KeymanEngine.LanguageResource, Package : KeymanEngine.TypedKeymanPackage<Resource>, Package == Resource.Package {
  public typealias AssociationInstaller = (KeymanEngine.LanguagePickAssociator.AssociationMap, @escaping (KeymanEngine.KeymanPackage.Key, KeymanEngine.AssociatingPackageInstaller<Resource, Package>.PackageInstallResult) -> Swift.Void) -> Swift.Void
  public typealias AssociatorBuilder = (KeymanEngine.AssociatingPackageInstaller<Resource, Package>, (KeymanEngine.LanguagePickAssociator.Progress) -> Swift.Void) -> KeymanEngine.LanguagePickAssociator
  public enum Associator {
    case lexicalModels
    case custom(KeymanEngine.AssociatingPackageInstaller<Resource, Package>.AssociatorBuilder, KeymanEngine.AssociatingPackageInstaller<Resource, Package>.AssociationInstaller)
  }
  public enum PackageInstallResult {
    case error(Swift.Error)
    case complete
  }
  public enum Progress {
    case cancelled
    case starting
    case inProgress
    case complete
    public static func == (a: KeymanEngine.AssociatingPackageInstaller<Resource, Package>.Progress, b: KeymanEngine.AssociatingPackageInstaller<Resource, Package>.Progress) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public typealias ProgressReceiver = (KeymanEngine.AssociatingPackageInstaller<Resource, Package>.Progress) -> Swift.Void
  convenience public init(for package: Package, defaultLanguageCode: Swift.String? = nil, withAssociators associators: [KeymanEngine.AssociatingPackageInstaller<Resource, Package>.Associator] = [], progressReceiver: @escaping KeymanEngine.AssociatingPackageInstaller<Resource, Package>.ProgressReceiver)
  @objc deinit
  public func promptForLanguages(inNavigationVC navVC: UIKit.UINavigationController)
  public func pickLanguages(withCodes languageIDs: Swift.Set<Swift.String>)
}
public enum GlobeKeyTapBehaviour {
  case switchToNextKeyboard
  case switchToNextInputMethod
  case doNothing
  public static func == (a: KeymanEngine.GlobeKeyTapBehaviour, b: KeymanEngine.GlobeKeyTapBehaviour) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum MenuBehaviour {
  case showAlways
  case showIfMultipleKeyboards
  case showNever
  public static func == (a: KeymanEngine.MenuBehaviour, b: KeymanEngine.MenuBehaviour) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class InputViewController : UIKit.UIInputViewController {
  @_Concurrency.MainActor(unsafe) public var menuCloseButtonTitle: Swift.String?
  @_Concurrency.MainActor(unsafe) public var isInputClickSoundEnabled: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var globeKeyTapBehaviour: KeymanEngine.GlobeKeyTapBehaviour
  @_Concurrency.MainActor(unsafe) public var menuBehaviour: KeymanEngine.MenuBehaviour
  @_Concurrency.MainActor(unsafe) open class var isPortrait: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) open class var topBarHeight: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc convenience dynamic public init()
  @_Concurrency.MainActor(unsafe) convenience public init(forSystem: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func updateViewConstraints()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func loadView()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewWillDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func textDidChange(_ textInput: UIKit.UITextInput?)
  @_Concurrency.MainActor(unsafe) public var isTopBarActive: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) public var activeTopBarHeight: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public var kmwHeight: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewWillTransition(to size: CoreFoundation.CGSize, with coordinator: UIKit.UIViewControllerTransitionCoordinator)
  @_Concurrency.MainActor(unsafe) public func setShouldReload()
  @_Concurrency.MainActor(unsafe) open func setBannerImage(to path: Swift.String)
  @objc deinit
}
public struct NotificationName<T> {
  public let name: Foundation.NSNotification.Name
  public init(name: Foundation.NSNotification.Name)
  public init(_ string: Swift.String)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class LexicalModelKeymanPackage : KeymanEngine.TypedKeymanPackage<KeymanEngine.InstallableLexicalModel> {
  override public func defaultInfoHtml() -> Swift.String
  @objc deinit
}
@objc @_Concurrency.MainActor(unsafe) open class SettingsViewController : UIKit.UITableViewController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor(unsafe) open func launchSettings(launchingVC: UIKit.UIViewController, sender: Any?)
  @_Concurrency.MainActor(unsafe) @objc dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func numberOfSections(in tableView: UIKit.UITableView) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) public func frameAtRightOfCell(cell cellFrame: CoreFoundation.CGRect, controlSize: CoreFoundation.CGSize) -> CoreFoundation.CGRect
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, willDisplay cell: UIKit.UITableViewCell, forRowAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, accessoryButtonTappedForRowWith indexPath: Foundation.IndexPath)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func prepare(for segue: UIKit.UIStoryboardSegue, sender: Any?)
  @_Concurrency.MainActor(unsafe) public static func installed2API(_ installedList: [KeymanEngine.InstallableLexicalModel]) -> [KeymanEngine.LexicalModel]
  @_Concurrency.MainActor(unsafe) public func setIsDoneButtonEnabled(_ nc: UIKit.UINavigationController, _ value: Swift.Bool)
  @objc deinit
}
public enum Key {
  public static let keyboardInfo: Swift.String
  public static let lexicalModelInfo: Swift.String
}
public enum Defaults {
  public static let keyboardID: KeymanEngine.FullKeyboardID
  public static let lexicalModelID: KeymanEngine.FullLexicalModelID
  public static var keyboardPackage: KeymanEngine.KeyboardKeymanPackage
  public static let lexicalModelPackage: KeymanEngine.LexicalModelKeymanPackage
  public static let keyboard: KeymanEngine.InstallableKeyboard
  public static let lexicalModel: KeymanEngine.InstallableLexicalModel
}
public enum Resources {
  public static let bundle: Foundation.Bundle
  public static let oskFontFilename: Swift.String
}
public enum Util {
  public static let isSystemKeyboard: Swift.Bool
  public static let sdkVersion: Swift.String
}
public enum FileExtensions {
  public static let javaScript: Swift.String
  public static let trueTypeFont: Swift.String
  public static let openTypeFont: Swift.String
  public static let configurationProfile: Swift.String
}
public enum KeymanError : Swift.Error, Foundation.LocalizedError {
  case unknown
  case missingFile(Swift.String, Swift.Bool)
}
public struct Keyboard : Swift.Codable {
  public var name: Swift.String
  public var id: Swift.String
  public var filename: Swift.String
  public var isDefault: Swift.Bool
  public var isRTL: Swift.Bool
  public var lastModified: Foundation.Date
  public var fileSize: Swift.Int?
  public var version: Swift.String
  public var languages: [KeymanEngine.Language]?
  public var font: KeymanEngine.Font?
  public var oskFont: KeymanEngine.Font?
  public init(name: Swift.String, id: Swift.String, filename: Swift.String, isDefault: Swift.Bool?, isRTL: Swift.Bool?, lastModified: Foundation.Date, fileSize: Swift.Int?, version: Swift.String, languages: [KeymanEngine.Language]?, font: KeymanEngine.Font?, oskFont: KeymanEngine.Font?)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
extension KeymanEngine.InstallableKeyboard : KeymanEngine.LanguageResource {}
extension KeymanEngine.Version.Tier : Swift.Equatable {}
extension KeymanEngine.Version.Tier : Swift.Hashable {}
extension KeymanEngine.Version.Tier : Swift.RawRepresentable {}
extension KeymanEngine.LanguageResourceType : Swift.Equatable {}
extension KeymanEngine.LanguageResourceType : Swift.Hashable {}
extension KeymanEngine.LanguageResourceType : Swift.RawRepresentable {}
extension KeymanEngine.InstallableLexicalModel : KeymanEngine.LanguageResource {}
@available(*, deprecated, message: "Version checks against keyboards and models are now based on their package.  Use `KeymanPackage.InstallationState` and `KeymanPackage.VersionState` instead.")
extension KeymanEngine.KeyboardState : Swift.Equatable {}
@available(*, deprecated, message: "Version checks against keyboards and models are now based on their package.  Use `KeymanPackage.InstallationState` and `KeymanPackage.VersionState` instead.")
extension KeymanEngine.KeyboardState : Swift.Hashable {}
extension KeymanEngine.VibrationSupport : Swift.Equatable {}
extension KeymanEngine.VibrationSupport : Swift.Hashable {}
extension KeymanEngine.SpacebarText : Swift.Equatable {}
extension KeymanEngine.SpacebarText : Swift.Hashable {}
extension KeymanEngine.SpacebarText : Swift.RawRepresentable {}
extension KeymanEngine.UpdateError : Swift.Equatable {}
extension KeymanEngine.UpdateError : Swift.Hashable {}
extension KeymanEngine.Queries.ResultError : Swift.Equatable {}
extension KeymanEngine.Queries.ResultError : Swift.Hashable {}
extension KeymanEngine.KMPError : Swift.Equatable {}
extension KeymanEngine.KMPError : Swift.Hashable {}
extension KeymanEngine.KMPError : Swift.RawRepresentable {}
extension KeymanEngine.KeymanPackage.DistributionMethod : Swift.Equatable {}
extension KeymanEngine.KeymanPackage.DistributionMethod : Swift.Hashable {}
extension KeymanEngine.KeymanPackage.DistributionMethod : Swift.RawRepresentable {}
extension KeymanEngine.KeymanPackage.VersionState : Swift.Equatable {}
extension KeymanEngine.KeymanPackage.VersionState : Swift.Hashable {}
extension KeymanEngine.KeymanPackage.VersionState : Swift.RawRepresentable {}
extension KeymanEngine.KeymanPackage.InstallationState : Swift.Equatable {}
extension KeymanEngine.KeymanPackage.InstallationState : Swift.Hashable {}
extension KeymanEngine.KeymanPackage.InstallationState : Swift.RawRepresentable {}
extension KeymanEngine.AssociatingPackageInstaller.Progress : Swift.Equatable {}
extension KeymanEngine.AssociatingPackageInstaller.Progress : Swift.Hashable {}
extension KeymanEngine.GlobeKeyTapBehaviour : Swift.Equatable {}
extension KeymanEngine.GlobeKeyTapBehaviour : Swift.Hashable {}
extension KeymanEngine.MenuBehaviour : Swift.Equatable {}
extension KeymanEngine.MenuBehaviour : Swift.Hashable {}
